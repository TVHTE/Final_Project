<style>

    .axis path,
    .axis line {
        fill: none;
        stroke: grey;
        stroke-width: 1;
        shape-rendering: crispEdges;
    }
    .line {
        stroke: steelblue;
        stroke-width: 2;
        fill: none;
    }

</style>

<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script> -->
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
<script src="/data/datamaps.world.min.js"></script>
<script src="https://d3js.org/queue.v1.min.js"></script>
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
<script src="https://d3js.org/d3-time-format.v2.min.js"></script>

<div id="container" style="position: relative; width: 1000px; height: 600px;"></div>
<script>

/** FUNCTIONS */

// filter the data from the dataset
function filter_JSON(json, key, value) {
    var result = [];
    json.forEach(function(val,idx,arr){
        if(val[key] == value){
            result.push(val)
        }
    })
    return result
    }

// update the graph according to selected country
function update_graph(data) {
    var color = d3.scale.ordinal().range(['red','green']);
    var type = ['Fossil', 'Renewable'];

    // scale the range of the data
    x.domain(d3.extent(data, function(d) { return d.YEAR; }));
    y.domain([0, 100]);

    line_svg.selectAll("text").remove()

    // nest the entries by country
    dataNest = d3.nest()
        .key(function(d) {return d.TYPE;})
        .entries(data);

    var result = dataNest.filter(function(val, idx, arr){
    	  return $("." + val.key).attr("fill") != "#ccc"
    	  // matching the data with selector status
    	})

    var country = line_svg.selectAll(".line")
        .data(result, function(d, i){return d.key[i]});

    country.enter().append("path")
        .attr("class", "line")
        .text(result, function(d){return d.CC})

    country.transition()
    	.style("stroke", function(d,i) { return d.color = color(d.key); })
    	.attr("id", function(d){ return 'tag'+d.key.replace(/\s+/g, '');}) // assign ID
    	.attr("d", function(d){
    		return line(d.values)
    	});

    country.exit().remove();

    line_svg.selectAll(".axis").remove();

    line_svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    var yaxis = line_svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)

    // add a label to the y axis
    line_svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - 60)
        .attr("x", 0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .text('% of total energy produced')
        .attr("class", "y axis label");


    // add legend to line chart
    var legend = line_svg.selectAll('g')
        .data(data)
        .enter()
        .append('g')
        .attr('class', 'legend');

    legend.append('rect')
        .attr('x', width - 20)
        .attr('y', function(d, i){ return i *  20;})
        .attr('width', 10)
        .attr('height', 10)
        .style('fill', function(d) {
          return color(d.TYPE);
        });

    legend.append('text')
        .attr('x', width - 8)
        .attr('y', function(d, i){ return (i *  20) + 9;})
        .text(function(d){ return d.TYPE; });

}



function update_bar(year, data){


    var type = ['Fossil', 'Renewable']
    var values = []
    var percentage = []
    var color = d3.scale.ordinal().range(['red','green']);
    var gap = 10
    var labelspace = 100
    var diff_values = []

    // get values according to year and clicked lands
    for (i = 0; i < data.length; i++){
        for (j = 0; j < data[i].length; j++){
            if (data[i][j]['YEAR'] == year){
                values.push(data[i][j])
                percentage.push([data[i][j],data[i][j - 1]])
            }
        }
    }

    for (var i = 0; i < percentage.length; i++){
        var now = percentage[i][0]['VALUE']
        var old = percentage[i][1]['VALUE']
        var diff = (((now - old) / old) * 100)
        diff_values.push(diff)
    }

    var country = values.map(function (d) {return d.CC});

    grouped_values = []

    // group data
    for (i = 0; i < values.length - 1; i++){
        if (values[i]['CC'] == values[i + 1]['CC']){
            grouped_values.push([values[i],values[i + 1]])
        }
    }

    console.log(grouped_values)

    var zipped_data = []

    for (var i = 0; i < grouped_values.length; i++){
        for (var j = 0; j < grouped_values[i].length; j++){
            zipped_data.push(grouped_values[i][j]['VALUE'])
        }
    }

    var chart_height = height_bar * zipped_data.length + gap * grouped_values.length;
    var group_height = height_bar * grouped_values.length

    var x = d3.scale.linear()
        .domain([0, d3.max(zipped_data)])
        .range([0, 1000]);

    var y = d3.scale.linear()
        .range([chart_height + gap, 0]);

    var yAxis = d3.svg.axis()
        .scale(y)
        .tickFormat('')
        .tickSize(0)
        .orient("left");

    bar_svg.selectAll('.bar')
        .remove()

    var bar = bar_svg.selectAll('.bar')
        .data(zipped_data)
        .enter().append('g')
        .attr('class', 'bar')
        .attr("transform", function(d, i) {
            console.log(Math.floor(i/grouped_values.length));
            return "translate(" + labelspace + "," + (i * height_bar + gap * 2) + ")";
        });

    bar.append('rect')
        .attr("fill", function(d,i) {
            return color(i % 2); })
        .attr('id', function(d, i) { return 'b' + i})
        .attr("width", x )
        .attr("height", height_bar - 1)

    bar_svg.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + labelspace + ", " + -gap/2 + ")")
        .call(yAxis);

    // Add text label in bar
    bar.append("text")
        .attr("x", function(d) { return x(d) - 20; })
        .attr("y", height_bar / 2)
        .attr("fill", "white")
        .attr("dy", ".35em")
        .text(function(d) { return Math.round(d); });

    // Draw labels
    bar.append("text")
        .attr("class", "label")
        .attr("x", - 50)
        .attr("y", function(d, i) { return i })
        .attr("dy", ".35em")
        .text(function(d,i) {
          return country[i];
      });

}

/** VARIABLES */

// margin for map
var margin = {top: 50, right: 80, bottom: 40, left: 160},
    width = 1300 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;

// margin for line
var margin_line = {top: 50, right: 80, bottom: 40, left: 160},
    width_line = 2000 - margin.left - margin.right,
    height_line = 800 - margin.top - margin.bottom;

// margin for bar
var margin_bar = {top: 0, right: 0, bottom: 0, left: 0},
    width_bar = 2000 - margin_bar.left - margin_bar.right,
    height_bar = 20 - margin_bar.top - margin_bar.bottom;

var x = d3.time.scale().range([0, width]),
    y = d3.scale.linear().range([height, 0]);

var xb = d3.scale.ordinal()
    .rangeRoundBands([0, width_bar], .1),
    xb1 = d3.scale.ordinal(),
    yb = d3.scale.linear().range([height_bar, 0]);

var xAxis = d3.svg.axis().scale(x)
    .orient("bottom").ticks(5),
    yAxis = d3.svg.axis().scale(y)
    .orient("left").ticks(5);

 // svg for line
var line_svg = d3.select("body")
    .append("svg")
        .attr('class', 'line_svg')
        .attr("width", width_line)
        .attr("height", height_line)
    .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");

var bar_svg = d3.select("body")
    .append("svg")
        .attr('class', 'bar_svg')
        .attr("width", width_bar)
        .attr("height", height)


var init_year = 1961

// slider
d3.select("body").insert("p", ":first-child").append("input")
  .attr("type", "range")
  .attr("min", "1961")
  .attr("max", "2017")
  .attr("value", init_year)
  .attr("id", "year");

// parse the date / time
var parseTime = d3.time.format("%Y").parse;

var line = d3.svg.line()
    .x(function(d) { return x(d.YEAR); })
    .y(function(d) { return y(d.VALUE); });

queue()
    .defer(d3.json, "/data/DATA_FOSL.json")
    .defer(d3.json, "/data/DATA_REN.json")
    .defer(d3.json, "/data/META.json")
    .defer(d3.json, "/data/data_project.json")
    .await(analyze);

function analyze(error, FOSL, REN, META, DATA) {
    if(error) { console.log(error); }

    var dataset = {}

    var onlyValues = META.map(function(obj){ return obj['CLASS']; });
    var minValue = Math.min.apply(null, onlyValues),
        maxValue = Math.max.apply(null, onlyValues);

    var paletteScale = d3.scale.linear()
           .domain([minValue,maxValue])
           .range(["#EFEFFF","#02386F"]);

    // fill dataset in appropriate format
    META.forEach(function(item){
        var iso = item['CC'],
            value = item['CLASS'];
            dataset[iso] = { income_class: value, fillColor: paletteScale(value) };
        });

    var data_bar  = []


    // render map
    var map = new Datamap({
        element: document.getElementById('container'),
        done: function(datamap) {
            datamap.svg.selectAll('.datamaps-subunit').on('click', function(geo) {
                id = geo.id;
                data = filter_JSON(DATA,'CC',id);
                update_graph(data)

                data_bar.push(data)
                j = 0

                // delete element if occurs more than 1 time
                for (var i = 1; i < data_bar.length; i++){
                    if (data_bar[i][0] == data[0]){
                        j += 1
                        if (j > 1){
                            data_bar.splice(i,1)
                        }
                    }
                }

                // use slider
                d3.select("#year").on("input", function() {
                    year = this.value
                    update_bar(year, data_bar)
                });
            });
        },
        projection: 'mercator', // big world map
        // countries don't listed in dataset will be painted with this color
        fills: { defaultFill: '#F5F5F5' },
        data: dataset,
        geographyConfig: {
            borderColor: '#DEDEDE',
            highlightBorderWidth: 2,
            // don't change color on mouse hover
            highlightFillColor: function(geo) {
                return geo['fillColor'] || '#F5F5F5';
            },
            // only change border
            highlightBorderColor: '#f4f142',
            // show desired information in tooltip
            popupTemplate: function(geo, data) {
                // don't show tooltip if country don't present in dataset
                if (!data) { return ; }
                // tooltip content
                return ['<div class="hoverinfo">',
                    '<strong>', geo.properties.name, '</strong>',
                    '<br>Income category: <strong>', data.income_class, '</strong>',
                    '</div>'].join('');
            }
        }
    });
}



</script>
